{"ast":null,"code":"import React, { PureComponent } from 'react';\nimport { classNames } from '../../utilities/css.js';\nimport { getRectForNode, Rect } from '../../utilities/geometry.js';\nimport { dataPolarisTopBar, layer } from '../shared.js';\nimport { windowRect, calculateVerticalPosition, calculateHorizontalPosition, rectIsOutsideOfRect, intersectionWithViewport } from './utilities/math.js';\nimport styles from './PositionedOverlay.scss.js';\nimport { Scrollable } from '../Scrollable/Scrollable.js';\nimport { EventListener } from '../EventListener/EventListener.js';\nconst OBSERVER_CONFIG = {\n  childList: true,\n  subtree: true,\n  characterData: true,\n  attributeFilter: ['style']\n};\nclass PositionedOverlay extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      measuring: true,\n      activatorRect: getRectForNode(this.props.activator),\n      right: undefined,\n      left: undefined,\n      top: 0,\n      height: 0,\n      width: null,\n      positioning: 'below',\n      zIndex: null,\n      outsideScrollableContainer: false,\n      lockPosition: false,\n      chevronOffset: 0\n    };\n    this.overlay = null;\n    this.scrollableContainers = [];\n    this.observer = void 0;\n    this.overlayDetails = () => {\n      const {\n        measuring,\n        left,\n        right,\n        positioning,\n        height,\n        activatorRect,\n        chevronOffset\n      } = this.state;\n      return {\n        measuring,\n        left,\n        right,\n        desiredHeight: height,\n        positioning,\n        activatorRect,\n        chevronOffset\n      };\n    };\n    this.setOverlay = node => {\n      this.overlay = node;\n    };\n    this.setScrollableContainers = () => {\n      const containers = [];\n      let scrollableContainer = Scrollable.forNode(this.props.activator);\n      if (scrollableContainer) {\n        containers.push(scrollableContainer);\n        while ((_scrollableContainer = scrollableContainer) !== null && _scrollableContainer !== void 0 && _scrollableContainer.parentElement) {\n          var _scrollableContainer;\n          scrollableContainer = Scrollable.forNode(scrollableContainer.parentElement);\n          containers.push(scrollableContainer);\n        }\n      }\n      this.scrollableContainers = containers;\n    };\n    this.registerScrollHandlers = () => {\n      this.scrollableContainers.forEach(node => {\n        node.addEventListener('scroll', this.handleMeasurement);\n      });\n    };\n    this.unregisterScrollHandlers = () => {\n      this.scrollableContainers.forEach(node => {\n        node.removeEventListener('scroll', this.handleMeasurement);\n      });\n    };\n    this.handleMeasurement = () => {\n      const {\n        lockPosition,\n        top\n      } = this.state;\n      this.observer.disconnect();\n      this.setState(_ref => {\n        let {\n          left,\n          top,\n          right\n        } = _ref;\n        return {\n          left,\n          right,\n          top,\n          height: 0,\n          positioning: 'below',\n          measuring: true\n        };\n      }, () => {\n        if (this.overlay == null || this.firstScrollableContainer == null) {\n          return;\n        }\n        const {\n          activator,\n          preferredPosition = 'below',\n          preferredAlignment = 'center',\n          onScrollOut,\n          fullWidth,\n          fixed,\n          preferInputActivator = true\n        } = this.props;\n        const preferredActivator = preferInputActivator ? activator.querySelector('input') || activator : activator;\n        const activatorRect = getRectForNode(preferredActivator);\n        const currentOverlayRect = getRectForNode(this.overlay);\n        const scrollableElement = isDocument(this.firstScrollableContainer) ? document.body : this.firstScrollableContainer;\n        const scrollableContainerRect = getRectForNode(scrollableElement);\n        const overlayRect = fullWidth ? new Rect({\n          ...currentOverlayRect,\n          width: activatorRect.width\n        }) : currentOverlayRect; // If `body` is 100% height, it still acts as though it were not constrained to that size. This adjusts for that.\n\n        if (scrollableElement === document.body) {\n          scrollableContainerRect.height = document.body.scrollHeight;\n        }\n        let topBarOffset = 0;\n        const topBarElement = scrollableElement.querySelector(`${dataPolarisTopBar.selector}`);\n        if (topBarElement) {\n          topBarOffset = topBarElement.clientHeight;\n        }\n        const overlayMargins = this.overlay.firstElementChild && this.overlay.firstChild instanceof HTMLElement ? getMarginsForNode(this.overlay.firstElementChild) : {\n          activator: 0,\n          container: 0,\n          horizontal: 0\n        };\n        const containerRect = windowRect();\n        const zIndexForLayer = getZIndexForLayerFromNode(activator);\n        const zIndex = zIndexForLayer == null ? zIndexForLayer : zIndexForLayer + 1;\n        const verticalPosition = calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed, topBarOffset);\n        const horizontalPosition = calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment);\n        const chevronOffset = activatorRect.center.x - horizontalPosition;\n        this.setState({\n          measuring: false,\n          activatorRect: getRectForNode(activator),\n          left: preferredAlignment !== 'right' ? horizontalPosition : undefined,\n          right: preferredAlignment === 'right' ? horizontalPosition : undefined,\n          top: lockPosition ? top : verticalPosition.top,\n          lockPosition: Boolean(fixed),\n          height: verticalPosition.height || 0,\n          width: fullWidth ? overlayRect.width : null,\n          positioning: verticalPosition.positioning,\n          outsideScrollableContainer: onScrollOut != null && rectIsOutsideOfRect(activatorRect, intersectionWithViewport(scrollableContainerRect)),\n          zIndex,\n          chevronOffset\n        }, () => {\n          if (!this.overlay) return;\n          this.observer.observe(this.overlay, OBSERVER_CONFIG);\n          this.observer.observe(activator, OBSERVER_CONFIG);\n        });\n      });\n    };\n    this.observer = new MutationObserver(this.handleMeasurement);\n  }\n  componentDidMount() {\n    this.setScrollableContainers();\n    if (this.scrollableContainers.length && !this.props.fixed) {\n      this.registerScrollHandlers();\n    }\n    this.handleMeasurement();\n  }\n  componentWillUnmount() {\n    this.observer.disconnect();\n    if (this.scrollableContainers.length && !this.props.fixed) {\n      this.unregisterScrollHandlers();\n    }\n  }\n  componentDidUpdate() {\n    const {\n      outsideScrollableContainer,\n      top\n    } = this.state;\n    const {\n      onScrollOut,\n      active\n    } = this.props;\n    if (active && onScrollOut != null && top !== 0 && outsideScrollableContainer) {\n      onScrollOut();\n    }\n  }\n  render() {\n    const {\n      left,\n      right,\n      top,\n      zIndex,\n      width\n    } = this.state;\n    const {\n      render,\n      fixed,\n      preventInteraction,\n      classNames: propClassNames,\n      zIndexOverride\n    } = this.props;\n    const style = {\n      top: top == null || isNaN(top) ? undefined : top,\n      left: left == null || isNaN(left) ? undefined : left,\n      right: right == null || isNaN(right) ? undefined : right,\n      width: width == null || isNaN(width) ? undefined : width,\n      zIndex: zIndexOverride || zIndex || undefined\n    };\n    const className = classNames(styles.PositionedOverlay, fixed && styles.fixed, preventInteraction && styles.preventInteraction, propClassNames);\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: className,\n      style: style,\n      ref: this.setOverlay\n    }, /*#__PURE__*/React.createElement(EventListener, {\n      event: \"resize\",\n      handler: this.handleMeasurement\n    }), render(this.overlayDetails()));\n  }\n  get firstScrollableContainer() {\n    var _this$scrollableConta;\n    return (_this$scrollableConta = this.scrollableContainers[0]) !== null && _this$scrollableConta !== void 0 ? _this$scrollableConta : null;\n  }\n  forceUpdatePosition() {\n    // Wait a single animation frame before re-measuring.\n    // Consumer's may also need to setup their own timers for\n    // triggering forceUpdatePosition() `children` use animation.\n    // Ideally, forceUpdatePosition() is fired at the end of a transition event.\n    requestAnimationFrame(this.handleMeasurement);\n  }\n}\nfunction getMarginsForNode(node) {\n  const nodeStyles = window.getComputedStyle(node);\n  return {\n    activator: parseFloat(nodeStyles.marginTop || '0'),\n    container: parseFloat(nodeStyles.marginBottom || '0'),\n    horizontal: parseFloat(nodeStyles.marginLeft || '0')\n  };\n}\nfunction getZIndexForLayerFromNode(node) {\n  const layerNode = node.closest(layer.selector) || document.body;\n  const zIndex = layerNode === document.body ? 'auto' : parseInt(window.getComputedStyle(layerNode).zIndex || '0', 10);\n  return zIndex === 'auto' || isNaN(zIndex) ? null : zIndex;\n}\nfunction isDocument(node) {\n  return node === document;\n}\nexport { PositionedOverlay };","map":{"version":3,"names":["React","PureComponent","classNames","getRectForNode","Rect","dataPolarisTopBar","layer","windowRect","calculateVerticalPosition","calculateHorizontalPosition","rectIsOutsideOfRect","intersectionWithViewport","styles","Scrollable","EventListener","OBSERVER_CONFIG","childList","subtree","characterData","attributeFilter","PositionedOverlay","constructor","props","state","measuring","activatorRect","activator","right","undefined","left","top","height","width","positioning","zIndex","outsideScrollableContainer","lockPosition","chevronOffset","overlay","scrollableContainers","observer","overlayDetails","desiredHeight","setOverlay","node","setScrollableContainers","containers","scrollableContainer","forNode","push","_scrollableContainer","parentElement","registerScrollHandlers","forEach","addEventListener","handleMeasurement","unregisterScrollHandlers","removeEventListener","disconnect","setState","_ref","firstScrollableContainer","preferredPosition","preferredAlignment","onScrollOut","fullWidth","fixed","preferInputActivator","preferredActivator","querySelector","currentOverlayRect","scrollableElement","isDocument","document","body","scrollableContainerRect","overlayRect","scrollHeight","topBarOffset","topBarElement","selector","clientHeight","overlayMargins","firstElementChild","firstChild","HTMLElement","getMarginsForNode","container","horizontal","containerRect","zIndexForLayer","getZIndexForLayerFromNode","verticalPosition","horizontalPosition","center","x","Boolean","observe","MutationObserver","componentDidMount","length","componentWillUnmount","componentDidUpdate","active","render","preventInteraction","propClassNames","zIndexOverride","style","isNaN","className","createElement","ref","event","handler","_this$scrollableConta","forceUpdatePosition","requestAnimationFrame","nodeStyles","window","getComputedStyle","parseFloat","marginTop","marginBottom","marginLeft","layerNode","closest","parseInt"],"sources":["/Users/jonaslemueldatu/node_modules/@shopify/polaris/build/esm/components/PositionedOverlay/PositionedOverlay.js"],"sourcesContent":["import React, { PureComponent } from 'react';\nimport { classNames } from '../../utilities/css.js';\nimport { getRectForNode, Rect } from '../../utilities/geometry.js';\nimport { dataPolarisTopBar, layer } from '../shared.js';\nimport { windowRect, calculateVerticalPosition, calculateHorizontalPosition, rectIsOutsideOfRect, intersectionWithViewport } from './utilities/math.js';\nimport styles from './PositionedOverlay.scss.js';\nimport { Scrollable } from '../Scrollable/Scrollable.js';\nimport { EventListener } from '../EventListener/EventListener.js';\n\nconst OBSERVER_CONFIG = {\n  childList: true,\n  subtree: true,\n  characterData: true,\n  attributeFilter: ['style']\n};\nclass PositionedOverlay extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      measuring: true,\n      activatorRect: getRectForNode(this.props.activator),\n      right: undefined,\n      left: undefined,\n      top: 0,\n      height: 0,\n      width: null,\n      positioning: 'below',\n      zIndex: null,\n      outsideScrollableContainer: false,\n      lockPosition: false,\n      chevronOffset: 0\n    };\n    this.overlay = null;\n    this.scrollableContainers = [];\n    this.observer = void 0;\n\n    this.overlayDetails = () => {\n      const {\n        measuring,\n        left,\n        right,\n        positioning,\n        height,\n        activatorRect,\n        chevronOffset\n      } = this.state;\n      return {\n        measuring,\n        left,\n        right,\n        desiredHeight: height,\n        positioning,\n        activatorRect,\n        chevronOffset\n      };\n    };\n\n    this.setOverlay = node => {\n      this.overlay = node;\n    };\n\n    this.setScrollableContainers = () => {\n      const containers = [];\n      let scrollableContainer = Scrollable.forNode(this.props.activator);\n\n      if (scrollableContainer) {\n        containers.push(scrollableContainer);\n\n        while ((_scrollableContainer = scrollableContainer) !== null && _scrollableContainer !== void 0 && _scrollableContainer.parentElement) {\n          var _scrollableContainer;\n\n          scrollableContainer = Scrollable.forNode(scrollableContainer.parentElement);\n          containers.push(scrollableContainer);\n        }\n      }\n\n      this.scrollableContainers = containers;\n    };\n\n    this.registerScrollHandlers = () => {\n      this.scrollableContainers.forEach(node => {\n        node.addEventListener('scroll', this.handleMeasurement);\n      });\n    };\n\n    this.unregisterScrollHandlers = () => {\n      this.scrollableContainers.forEach(node => {\n        node.removeEventListener('scroll', this.handleMeasurement);\n      });\n    };\n\n    this.handleMeasurement = () => {\n      const {\n        lockPosition,\n        top\n      } = this.state;\n      this.observer.disconnect();\n      this.setState(({\n        left,\n        top,\n        right\n      }) => ({\n        left,\n        right,\n        top,\n        height: 0,\n        positioning: 'below',\n        measuring: true\n      }), () => {\n        if (this.overlay == null || this.firstScrollableContainer == null) {\n          return;\n        }\n\n        const {\n          activator,\n          preferredPosition = 'below',\n          preferredAlignment = 'center',\n          onScrollOut,\n          fullWidth,\n          fixed,\n          preferInputActivator = true\n        } = this.props;\n        const preferredActivator = preferInputActivator ? activator.querySelector('input') || activator : activator;\n        const activatorRect = getRectForNode(preferredActivator);\n        const currentOverlayRect = getRectForNode(this.overlay);\n        const scrollableElement = isDocument(this.firstScrollableContainer) ? document.body : this.firstScrollableContainer;\n        const scrollableContainerRect = getRectForNode(scrollableElement);\n        const overlayRect = fullWidth ? new Rect({ ...currentOverlayRect,\n          width: activatorRect.width\n        }) : currentOverlayRect; // If `body` is 100% height, it still acts as though it were not constrained to that size. This adjusts for that.\n\n        if (scrollableElement === document.body) {\n          scrollableContainerRect.height = document.body.scrollHeight;\n        }\n\n        let topBarOffset = 0;\n        const topBarElement = scrollableElement.querySelector(`${dataPolarisTopBar.selector}`);\n\n        if (topBarElement) {\n          topBarOffset = topBarElement.clientHeight;\n        }\n\n        const overlayMargins = this.overlay.firstElementChild && this.overlay.firstChild instanceof HTMLElement ? getMarginsForNode(this.overlay.firstElementChild) : {\n          activator: 0,\n          container: 0,\n          horizontal: 0\n        };\n        const containerRect = windowRect();\n        const zIndexForLayer = getZIndexForLayerFromNode(activator);\n        const zIndex = zIndexForLayer == null ? zIndexForLayer : zIndexForLayer + 1;\n        const verticalPosition = calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed, topBarOffset);\n        const horizontalPosition = calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment);\n        const chevronOffset = activatorRect.center.x - horizontalPosition;\n        this.setState({\n          measuring: false,\n          activatorRect: getRectForNode(activator),\n          left: preferredAlignment !== 'right' ? horizontalPosition : undefined,\n          right: preferredAlignment === 'right' ? horizontalPosition : undefined,\n          top: lockPosition ? top : verticalPosition.top,\n          lockPosition: Boolean(fixed),\n          height: verticalPosition.height || 0,\n          width: fullWidth ? overlayRect.width : null,\n          positioning: verticalPosition.positioning,\n          outsideScrollableContainer: onScrollOut != null && rectIsOutsideOfRect(activatorRect, intersectionWithViewport(scrollableContainerRect)),\n          zIndex,\n          chevronOffset\n        }, () => {\n          if (!this.overlay) return;\n          this.observer.observe(this.overlay, OBSERVER_CONFIG);\n          this.observer.observe(activator, OBSERVER_CONFIG);\n        });\n      });\n    };\n\n    this.observer = new MutationObserver(this.handleMeasurement);\n  }\n\n  componentDidMount() {\n    this.setScrollableContainers();\n\n    if (this.scrollableContainers.length && !this.props.fixed) {\n      this.registerScrollHandlers();\n    }\n\n    this.handleMeasurement();\n  }\n\n  componentWillUnmount() {\n    this.observer.disconnect();\n\n    if (this.scrollableContainers.length && !this.props.fixed) {\n      this.unregisterScrollHandlers();\n    }\n  }\n\n  componentDidUpdate() {\n    const {\n      outsideScrollableContainer,\n      top\n    } = this.state;\n    const {\n      onScrollOut,\n      active\n    } = this.props;\n\n    if (active && onScrollOut != null && top !== 0 && outsideScrollableContainer) {\n      onScrollOut();\n    }\n  }\n\n  render() {\n    const {\n      left,\n      right,\n      top,\n      zIndex,\n      width\n    } = this.state;\n    const {\n      render,\n      fixed,\n      preventInteraction,\n      classNames: propClassNames,\n      zIndexOverride\n    } = this.props;\n    const style = {\n      top: top == null || isNaN(top) ? undefined : top,\n      left: left == null || isNaN(left) ? undefined : left,\n      right: right == null || isNaN(right) ? undefined : right,\n      width: width == null || isNaN(width) ? undefined : width,\n      zIndex: zIndexOverride || zIndex || undefined\n    };\n    const className = classNames(styles.PositionedOverlay, fixed && styles.fixed, preventInteraction && styles.preventInteraction, propClassNames);\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: className,\n      style: style,\n      ref: this.setOverlay\n    }, /*#__PURE__*/React.createElement(EventListener, {\n      event: \"resize\",\n      handler: this.handleMeasurement\n    }), render(this.overlayDetails()));\n  }\n\n  get firstScrollableContainer() {\n    var _this$scrollableConta;\n\n    return (_this$scrollableConta = this.scrollableContainers[0]) !== null && _this$scrollableConta !== void 0 ? _this$scrollableConta : null;\n  }\n\n  forceUpdatePosition() {\n    // Wait a single animation frame before re-measuring.\n    // Consumer's may also need to setup their own timers for\n    // triggering forceUpdatePosition() `children` use animation.\n    // Ideally, forceUpdatePosition() is fired at the end of a transition event.\n    requestAnimationFrame(this.handleMeasurement);\n  }\n\n}\n\nfunction getMarginsForNode(node) {\n  const nodeStyles = window.getComputedStyle(node);\n  return {\n    activator: parseFloat(nodeStyles.marginTop || '0'),\n    container: parseFloat(nodeStyles.marginBottom || '0'),\n    horizontal: parseFloat(nodeStyles.marginLeft || '0')\n  };\n}\n\nfunction getZIndexForLayerFromNode(node) {\n  const layerNode = node.closest(layer.selector) || document.body;\n  const zIndex = layerNode === document.body ? 'auto' : parseInt(window.getComputedStyle(layerNode).zIndex || '0', 10);\n  return zIndex === 'auto' || isNaN(zIndex) ? null : zIndex;\n}\n\nfunction isDocument(node) {\n  return node === document;\n}\n\nexport { PositionedOverlay };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"// Unfortunately, this is how we have to type this at the moment.\n// There is currently a proposal to support variadic kinds.\n// https://github.com/Microsoft/TypeScript/issues/5453\nfunction merge() {\n  let final = {};\n  for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {\n    objs[_key] = arguments[_key];\n  }\n  for (const obj of objs) {\n    final = mergeRecursively(final, obj);\n  }\n  return final;\n}\nfunction mergeRecursively(inputObjA, objB) {\n  const objA = Array.isArray(inputObjA) ? [...inputObjA] : {\n    ...inputObjA\n  };\n  for (const key in objB) {\n    if (!Object.prototype.hasOwnProperty.call(objB, key)) {\n      continue;\n    } else if (isMergeableValue(objB[key]) && isMergeableValue(objA[key])) {\n      objA[key] = mergeRecursively(objA[key], objB[key]);\n    } else {\n      objA[key] = objB[key];\n    }\n  }\n  return objA;\n}\nfunction isMergeableValue(value) {\n  return value !== null && typeof value === 'object';\n}\nexport { merge };","map":{"version":3,"names":["merge","final","_len","arguments","length","objs","Array","_key","obj","mergeRecursively","inputObjA","objB","objA","isArray","key","Object","prototype","hasOwnProperty","call","isMergeableValue","value"],"sources":["/Users/jonaslemueldatu/node_modules/@shopify/polaris/build/esm/utilities/merge.js"],"sourcesContent":["// Unfortunately, this is how we have to type this at the moment.\n// There is currently a proposal to support variadic kinds.\n// https://github.com/Microsoft/TypeScript/issues/5453\nfunction merge(...objs) {\n  let final = {};\n\n  for (const obj of objs) {\n    final = mergeRecursively(final, obj);\n  }\n\n  return final;\n}\n\nfunction mergeRecursively(inputObjA, objB) {\n  const objA = Array.isArray(inputObjA) ? [...inputObjA] : { ...inputObjA\n  };\n\n  for (const key in objB) {\n    if (!Object.prototype.hasOwnProperty.call(objB, key)) {\n      continue;\n    } else if (isMergeableValue(objB[key]) && isMergeableValue(objA[key])) {\n      objA[key] = mergeRecursively(objA[key], objB[key]);\n    } else {\n      objA[key] = objB[key];\n    }\n  }\n\n  return objA;\n}\n\nfunction isMergeableValue(value) {\n  return value !== null && typeof value === 'object';\n}\n\nexport { merge };\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,KAAKA,CAAA,EAAU;EACtB,IAAIC,KAAK,GAAG,CAAC,CAAC;EAAC,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EADCC,IAAI,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;IAAJF,IAAI,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;EAAA;EAGpB,KAAK,MAAMC,GAAG,IAAIH,IAAI,EAAE;IACtBJ,KAAK,GAAGQ,gBAAgB,CAACR,KAAK,EAAEO,GAAG,CAAC;EACtC;EAEA,OAAOP,KAAK;AACd;AAEA,SAASQ,gBAAgBA,CAACC,SAAS,EAAEC,IAAI,EAAE;EACzC,MAAMC,IAAI,GAAGN,KAAK,CAACO,OAAO,CAACH,SAAS,CAAC,GAAG,CAAC,GAAGA,SAAS,CAAC,GAAG;IAAE,GAAGA;EAC9D,CAAC;EAED,KAAK,MAAMI,GAAG,IAAIH,IAAI,EAAE;IACtB,IAAI,CAACI,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACP,IAAI,EAAEG,GAAG,CAAC,EAAE;MACpD;IACF,CAAC,MAAM,IAAIK,gBAAgB,CAACR,IAAI,CAACG,GAAG,CAAC,CAAC,IAAIK,gBAAgB,CAACP,IAAI,CAACE,GAAG,CAAC,CAAC,EAAE;MACrEF,IAAI,CAACE,GAAG,CAAC,GAAGL,gBAAgB,CAACG,IAAI,CAACE,GAAG,CAAC,EAAEH,IAAI,CAACG,GAAG,CAAC,CAAC;IACpD,CAAC,MAAM;MACLF,IAAI,CAACE,GAAG,CAAC,GAAGH,IAAI,CAACG,GAAG,CAAC;IACvB;EACF;EAEA,OAAOF,IAAI;AACb;AAEA,SAASO,gBAAgBA,CAACC,KAAK,EAAE;EAC/B,OAAOA,KAAK,KAAK,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ;AACpD;AAEA,SAASpB,KAAK"},"metadata":{},"sourceType":"module","externalDependencies":[]}
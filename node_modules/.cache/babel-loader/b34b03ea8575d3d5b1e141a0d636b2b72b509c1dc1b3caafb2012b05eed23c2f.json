{"ast":null,"code":"import { Rect } from '../../../utilities/geometry.js';\nfunction calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed) {\n  let topBarOffset = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n  const activatorTop = activatorRect.top;\n  const activatorBottom = activatorTop + activatorRect.height;\n  const spaceAbove = activatorRect.top - topBarOffset;\n  const spaceBelow = containerRect.height - activatorRect.top - activatorRect.height;\n  const desiredHeight = overlayRect.height;\n  const verticalMargins = overlayMargins.activator + overlayMargins.container;\n  const minimumSpaceToScroll = overlayMargins.container;\n  const distanceToTopScroll = activatorRect.top - Math.max(scrollableContainerRect.top, 0);\n  const distanceToBottomScroll = containerRect.top + Math.min(containerRect.height, scrollableContainerRect.top + scrollableContainerRect.height) - (activatorRect.top + activatorRect.height);\n  const enoughSpaceFromTopScroll = distanceToTopScroll >= minimumSpaceToScroll;\n  const enoughSpaceFromBottomScroll = distanceToBottomScroll >= minimumSpaceToScroll;\n  const heightIfBelow = Math.min(spaceBelow, desiredHeight);\n  const heightIfAbove = Math.min(spaceAbove, desiredHeight);\n  const containerRectTop = fixed ? 0 : containerRect.top;\n  const positionIfAbove = {\n    height: heightIfAbove - verticalMargins,\n    top: activatorTop + containerRectTop - heightIfAbove,\n    positioning: 'above'\n  };\n  const positionIfBelow = {\n    height: heightIfBelow - verticalMargins,\n    top: activatorBottom + containerRectTop,\n    positioning: 'below'\n  };\n  if (preferredPosition === 'above') {\n    return (enoughSpaceFromTopScroll || distanceToTopScroll >= distanceToBottomScroll && !enoughSpaceFromBottomScroll) && (spaceAbove > desiredHeight || spaceAbove > spaceBelow) ? positionIfAbove : positionIfBelow;\n  }\n  if (preferredPosition === 'below') {\n    return (enoughSpaceFromBottomScroll || distanceToBottomScroll >= distanceToTopScroll && !enoughSpaceFromTopScroll) && (spaceBelow > desiredHeight || spaceBelow > spaceAbove) ? positionIfBelow : positionIfAbove;\n  }\n  if (enoughSpaceFromTopScroll && enoughSpaceFromBottomScroll) {\n    return spaceAbove > spaceBelow ? positionIfAbove : positionIfBelow;\n  }\n  return distanceToTopScroll > minimumSpaceToScroll ? positionIfAbove : positionIfBelow;\n}\nfunction calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment) {\n  const maximum = containerRect.width - overlayRect.width;\n  if (preferredAlignment === 'left') {\n    return Math.min(maximum, Math.max(0, activatorRect.left - overlayMargins.horizontal));\n  } else if (preferredAlignment === 'right') {\n    const activatorRight = containerRect.width - (activatorRect.left + activatorRect.width);\n    return Math.min(maximum, Math.max(0, activatorRight - overlayMargins.horizontal));\n  }\n  return Math.min(maximum, Math.max(0, activatorRect.center.x - overlayRect.width / 2));\n}\nfunction rectIsOutsideOfRect(inner, outer) {\n  const {\n    center\n  } = inner;\n  return center.y < outer.top || center.y > outer.top + outer.height;\n}\nfunction intersectionWithViewport(rect) {\n  let viewport = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : windowRect();\n  const top = Math.max(rect.top, 0);\n  const left = Math.max(rect.left, 0);\n  const bottom = Math.min(rect.top + rect.height, viewport.height);\n  const right = Math.min(rect.left + rect.width, viewport.width);\n  return new Rect({\n    top,\n    left,\n    height: bottom - top,\n    width: right - left\n  });\n}\nfunction windowRect() {\n  return new Rect({\n    top: window.scrollY,\n    left: window.scrollX,\n    height: window.innerHeight,\n    width: document.body.clientWidth\n  });\n}\nexport { calculateHorizontalPosition, calculateVerticalPosition, intersectionWithViewport, rectIsOutsideOfRect, windowRect };","map":{"version":3,"names":["Rect","calculateVerticalPosition","activatorRect","overlayRect","overlayMargins","scrollableContainerRect","containerRect","preferredPosition","fixed","topBarOffset","arguments","length","undefined","activatorTop","top","activatorBottom","height","spaceAbove","spaceBelow","desiredHeight","verticalMargins","activator","container","minimumSpaceToScroll","distanceToTopScroll","Math","max","distanceToBottomScroll","min","enoughSpaceFromTopScroll","enoughSpaceFromBottomScroll","heightIfBelow","heightIfAbove","containerRectTop","positionIfAbove","positioning","positionIfBelow","calculateHorizontalPosition","preferredAlignment","maximum","width","left","horizontal","activatorRight","center","x","rectIsOutsideOfRect","inner","outer","y","intersectionWithViewport","rect","viewport","windowRect","bottom","right","window","scrollY","scrollX","innerHeight","document","body","clientWidth"],"sources":["/Users/jonaslemueldatu/node_modules/@shopify/polaris/build/esm/components/PositionedOverlay/utilities/math.js"],"sourcesContent":["import { Rect } from '../../../utilities/geometry.js';\n\nfunction calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed, topBarOffset = 0) {\n  const activatorTop = activatorRect.top;\n  const activatorBottom = activatorTop + activatorRect.height;\n  const spaceAbove = activatorRect.top - topBarOffset;\n  const spaceBelow = containerRect.height - activatorRect.top - activatorRect.height;\n  const desiredHeight = overlayRect.height;\n  const verticalMargins = overlayMargins.activator + overlayMargins.container;\n  const minimumSpaceToScroll = overlayMargins.container;\n  const distanceToTopScroll = activatorRect.top - Math.max(scrollableContainerRect.top, 0);\n  const distanceToBottomScroll = containerRect.top + Math.min(containerRect.height, scrollableContainerRect.top + scrollableContainerRect.height) - (activatorRect.top + activatorRect.height);\n  const enoughSpaceFromTopScroll = distanceToTopScroll >= minimumSpaceToScroll;\n  const enoughSpaceFromBottomScroll = distanceToBottomScroll >= minimumSpaceToScroll;\n  const heightIfBelow = Math.min(spaceBelow, desiredHeight);\n  const heightIfAbove = Math.min(spaceAbove, desiredHeight);\n  const containerRectTop = fixed ? 0 : containerRect.top;\n  const positionIfAbove = {\n    height: heightIfAbove - verticalMargins,\n    top: activatorTop + containerRectTop - heightIfAbove,\n    positioning: 'above'\n  };\n  const positionIfBelow = {\n    height: heightIfBelow - verticalMargins,\n    top: activatorBottom + containerRectTop,\n    positioning: 'below'\n  };\n\n  if (preferredPosition === 'above') {\n    return (enoughSpaceFromTopScroll || distanceToTopScroll >= distanceToBottomScroll && !enoughSpaceFromBottomScroll) && (spaceAbove > desiredHeight || spaceAbove > spaceBelow) ? positionIfAbove : positionIfBelow;\n  }\n\n  if (preferredPosition === 'below') {\n    return (enoughSpaceFromBottomScroll || distanceToBottomScroll >= distanceToTopScroll && !enoughSpaceFromTopScroll) && (spaceBelow > desiredHeight || spaceBelow > spaceAbove) ? positionIfBelow : positionIfAbove;\n  }\n\n  if (enoughSpaceFromTopScroll && enoughSpaceFromBottomScroll) {\n    return spaceAbove > spaceBelow ? positionIfAbove : positionIfBelow;\n  }\n\n  return distanceToTopScroll > minimumSpaceToScroll ? positionIfAbove : positionIfBelow;\n}\nfunction calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment) {\n  const maximum = containerRect.width - overlayRect.width;\n\n  if (preferredAlignment === 'left') {\n    return Math.min(maximum, Math.max(0, activatorRect.left - overlayMargins.horizontal));\n  } else if (preferredAlignment === 'right') {\n    const activatorRight = containerRect.width - (activatorRect.left + activatorRect.width);\n    return Math.min(maximum, Math.max(0, activatorRight - overlayMargins.horizontal));\n  }\n\n  return Math.min(maximum, Math.max(0, activatorRect.center.x - overlayRect.width / 2));\n}\nfunction rectIsOutsideOfRect(inner, outer) {\n  const {\n    center\n  } = inner;\n  return center.y < outer.top || center.y > outer.top + outer.height;\n}\nfunction intersectionWithViewport(rect, viewport = windowRect()) {\n  const top = Math.max(rect.top, 0);\n  const left = Math.max(rect.left, 0);\n  const bottom = Math.min(rect.top + rect.height, viewport.height);\n  const right = Math.min(rect.left + rect.width, viewport.width);\n  return new Rect({\n    top,\n    left,\n    height: bottom - top,\n    width: right - left\n  });\n}\nfunction windowRect() {\n  return new Rect({\n    top: window.scrollY,\n    left: window.scrollX,\n    height: window.innerHeight,\n    width: document.body.clientWidth\n  });\n}\n\nexport { calculateHorizontalPosition, calculateVerticalPosition, intersectionWithViewport, rectIsOutsideOfRect, windowRect };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { space } from '@shopify/polaris-tokens';\nimport { debounce } from '../debounce.js';\nimport { scrollable, dataPolarisTopBar } from '../../components/shared.js';\nimport { stackedContent } from '../breakpoints.js';\nimport { getRectForNode } from '../geometry.js';\nconst SIXTY_FPS = 1000 / 60;\nclass StickyManager {\n  constructor(container) {\n    this.stickyItems = [];\n    this.stuckItems = [];\n    this.container = null;\n    this.topBarOffset = 0;\n    this.handleResize = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    this.handleScroll = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n  registerStickyItem(stickyItem) {\n    this.stickyItems.push(stickyItem);\n  }\n  unregisterStickyItem(nodeToRemove) {\n    const nodeIndex = this.stickyItems.findIndex(_ref => {\n      let {\n        stickyNode\n      } = _ref;\n      return nodeToRemove === stickyNode;\n    });\n    this.stickyItems.splice(nodeIndex, 1);\n  }\n  setContainer(el) {\n    this.container = el;\n    if (isDocument(el)) {\n      this.setTopBarOffset(el);\n    }\n    this.container.addEventListener('scroll', this.handleScroll);\n    window.addEventListener('resize', this.handleResize);\n    this.manageStickyItems();\n  }\n  removeScrollListener() {\n    if (this.container) {\n      this.container.removeEventListener('scroll', this.handleScroll);\n      window.removeEventListener('resize', this.handleResize);\n    }\n  }\n  manageStickyItems() {\n    if (this.stickyItems.length <= 0) {\n      return;\n    }\n    const scrollTop = this.container ? scrollTopFor(this.container) : 0;\n    const containerTop = getRectForNode(this.container).top + this.topBarOffset;\n    this.stickyItems.forEach(stickyItem => {\n      const {\n        handlePositioning\n      } = stickyItem;\n      const {\n        sticky,\n        top,\n        left,\n        width\n      } = this.evaluateStickyItem(stickyItem, scrollTop, containerTop);\n      this.updateStuckItems(stickyItem, sticky);\n      handlePositioning(sticky, top, left, width);\n    });\n  }\n  evaluateStickyItem(stickyItem, scrollTop, containerTop) {\n    const {\n      stickyNode,\n      placeHolderNode,\n      boundingElement,\n      offset,\n      disableWhenStacked\n    } = stickyItem;\n    if (disableWhenStacked && stackedContent().matches) {\n      return {\n        sticky: false,\n        top: 0,\n        left: 0,\n        width: 'auto'\n      };\n    }\n    const stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(space['space-5'], 10) : this.getOffset(stickyNode);\n    const scrollPosition = scrollTop + stickyOffset;\n    const placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;\n    const top = containerTop + stickyOffset;\n    const width = placeHolderNode.getBoundingClientRect().width;\n    const left = placeHolderNode.getBoundingClientRect().left;\n    let sticky;\n    if (boundingElement == null) {\n      sticky = scrollPosition >= placeHolderNodeCurrentTop;\n    } else {\n      var _stickyNode$firstElem;\n      const stickyItemHeight = stickyNode.getBoundingClientRect().height || ((_stickyNode$firstElem = stickyNode.firstElementChild) === null || _stickyNode$firstElem === void 0 ? void 0 : _stickyNode$firstElem.getBoundingClientRect().height) || 0;\n      const stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;\n      sticky = scrollPosition >= placeHolderNodeCurrentTop && scrollPosition < stickyItemBottomPosition;\n    }\n    return {\n      sticky,\n      top,\n      left,\n      width\n    };\n  }\n  updateStuckItems(item, sticky) {\n    const {\n      stickyNode\n    } = item;\n    if (sticky && !this.isNodeStuck(stickyNode)) {\n      this.addStuckItem(item);\n    } else if (!sticky && this.isNodeStuck(stickyNode)) {\n      this.removeStuckItem(item);\n    }\n  }\n  addStuckItem(stickyItem) {\n    this.stuckItems.push(stickyItem);\n  }\n  removeStuckItem(stickyItem) {\n    const {\n      stickyNode: nodeToRemove\n    } = stickyItem;\n    const nodeIndex = this.stuckItems.findIndex(_ref2 => {\n      let {\n        stickyNode\n      } = _ref2;\n      return nodeToRemove === stickyNode;\n    });\n    this.stuckItems.splice(nodeIndex, 1);\n  }\n  getOffset(node) {\n    if (this.stuckItems.length === 0) {\n      return 0;\n    }\n    let offset = 0;\n    let count = 0;\n    const stuckNodesLength = this.stuckItems.length;\n    const nodeRect = getRectForNode(node);\n    while (count < stuckNodesLength) {\n      const stuckNode = this.stuckItems[count].stickyNode;\n      if (stuckNode !== node) {\n        const stuckNodeRect = getRectForNode(stuckNode);\n        if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {\n          offset += getRectForNode(stuckNode).height;\n        }\n      } else {\n        break;\n      }\n      count++;\n    }\n    return offset;\n  }\n  isNodeStuck(node) {\n    const nodeFound = this.stuckItems.findIndex(_ref3 => {\n      let {\n        stickyNode\n      } = _ref3;\n      return node === stickyNode;\n    });\n    return nodeFound >= 0;\n  }\n  setTopBarOffset(container) {\n    const topbarElement = container.querySelector(`:not(${scrollable.selector}) ${dataPolarisTopBar.selector}`);\n    this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;\n  }\n}\nfunction isDocument(node) {\n  return node === document;\n}\nfunction scrollTopFor(container) {\n  return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;\n}\nfunction horizontallyOverlaps(rect1, rect2) {\n  const rect1Left = rect1.left;\n  const rect1Right = rect1.left + rect1.width;\n  const rect2Left = rect2.left;\n  const rect2Right = rect2.left + rect2.width;\n  return rect2Right < rect1Left || rect1Right < rect2Left;\n}\nexport { StickyManager };","map":{"version":3,"names":["space","debounce","scrollable","dataPolarisTopBar","stackedContent","getRectForNode","SIXTY_FPS","StickyManager","constructor","container","stickyItems","stuckItems","topBarOffset","handleResize","manageStickyItems","leading","trailing","maxWait","handleScroll","setContainer","registerStickyItem","stickyItem","push","unregisterStickyItem","nodeToRemove","nodeIndex","findIndex","_ref","stickyNode","splice","el","isDocument","setTopBarOffset","addEventListener","window","removeScrollListener","removeEventListener","length","scrollTop","scrollTopFor","containerTop","top","forEach","handlePositioning","sticky","left","width","evaluateStickyItem","updateStuckItems","placeHolderNode","boundingElement","offset","disableWhenStacked","matches","stickyOffset","getOffset","parseInt","scrollPosition","placeHolderNodeCurrentTop","getBoundingClientRect","_stickyNode$firstElem","stickyItemHeight","height","firstElementChild","stickyItemBottomPosition","bottom","item","isNodeStuck","addStuckItem","removeStuckItem","_ref2","node","count","stuckNodesLength","nodeRect","stuckNode","stuckNodeRect","horizontallyOverlaps","nodeFound","_ref3","topbarElement","querySelector","selector","clientHeight","document","body","documentElement","rect1","rect2","rect1Left","rect1Right","rect2Left","rect2Right"],"sources":["/Users/jonaslemueldatu/node_modules/@shopify/polaris/build/esm/utilities/sticky-manager/sticky-manager.js"],"sourcesContent":["import { space } from '@shopify/polaris-tokens';\nimport { debounce } from '../debounce.js';\nimport { scrollable, dataPolarisTopBar } from '../../components/shared.js';\nimport { stackedContent } from '../breakpoints.js';\nimport { getRectForNode } from '../geometry.js';\n\nconst SIXTY_FPS = 1000 / 60;\nclass StickyManager {\n  constructor(container) {\n    this.stickyItems = [];\n    this.stuckItems = [];\n    this.container = null;\n    this.topBarOffset = 0;\n    this.handleResize = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    this.handleScroll = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n\n  registerStickyItem(stickyItem) {\n    this.stickyItems.push(stickyItem);\n  }\n\n  unregisterStickyItem(nodeToRemove) {\n    const nodeIndex = this.stickyItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stickyItems.splice(nodeIndex, 1);\n  }\n\n  setContainer(el) {\n    this.container = el;\n\n    if (isDocument(el)) {\n      this.setTopBarOffset(el);\n    }\n\n    this.container.addEventListener('scroll', this.handleScroll);\n    window.addEventListener('resize', this.handleResize);\n    this.manageStickyItems();\n  }\n\n  removeScrollListener() {\n    if (this.container) {\n      this.container.removeEventListener('scroll', this.handleScroll);\n      window.removeEventListener('resize', this.handleResize);\n    }\n  }\n\n  manageStickyItems() {\n    if (this.stickyItems.length <= 0) {\n      return;\n    }\n\n    const scrollTop = this.container ? scrollTopFor(this.container) : 0;\n    const containerTop = getRectForNode(this.container).top + this.topBarOffset;\n    this.stickyItems.forEach(stickyItem => {\n      const {\n        handlePositioning\n      } = stickyItem;\n      const {\n        sticky,\n        top,\n        left,\n        width\n      } = this.evaluateStickyItem(stickyItem, scrollTop, containerTop);\n      this.updateStuckItems(stickyItem, sticky);\n      handlePositioning(sticky, top, left, width);\n    });\n  }\n\n  evaluateStickyItem(stickyItem, scrollTop, containerTop) {\n    const {\n      stickyNode,\n      placeHolderNode,\n      boundingElement,\n      offset,\n      disableWhenStacked\n    } = stickyItem;\n\n    if (disableWhenStacked && stackedContent().matches) {\n      return {\n        sticky: false,\n        top: 0,\n        left: 0,\n        width: 'auto'\n      };\n    }\n\n    const stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(space['space-5'], 10) : this.getOffset(stickyNode);\n    const scrollPosition = scrollTop + stickyOffset;\n    const placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;\n    const top = containerTop + stickyOffset;\n    const width = placeHolderNode.getBoundingClientRect().width;\n    const left = placeHolderNode.getBoundingClientRect().left;\n    let sticky;\n\n    if (boundingElement == null) {\n      sticky = scrollPosition >= placeHolderNodeCurrentTop;\n    } else {\n      var _stickyNode$firstElem;\n\n      const stickyItemHeight = stickyNode.getBoundingClientRect().height || ((_stickyNode$firstElem = stickyNode.firstElementChild) === null || _stickyNode$firstElem === void 0 ? void 0 : _stickyNode$firstElem.getBoundingClientRect().height) || 0;\n      const stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;\n      sticky = scrollPosition >= placeHolderNodeCurrentTop && scrollPosition < stickyItemBottomPosition;\n    }\n\n    return {\n      sticky,\n      top,\n      left,\n      width\n    };\n  }\n\n  updateStuckItems(item, sticky) {\n    const {\n      stickyNode\n    } = item;\n\n    if (sticky && !this.isNodeStuck(stickyNode)) {\n      this.addStuckItem(item);\n    } else if (!sticky && this.isNodeStuck(stickyNode)) {\n      this.removeStuckItem(item);\n    }\n  }\n\n  addStuckItem(stickyItem) {\n    this.stuckItems.push(stickyItem);\n  }\n\n  removeStuckItem(stickyItem) {\n    const {\n      stickyNode: nodeToRemove\n    } = stickyItem;\n    const nodeIndex = this.stuckItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stuckItems.splice(nodeIndex, 1);\n  }\n\n  getOffset(node) {\n    if (this.stuckItems.length === 0) {\n      return 0;\n    }\n\n    let offset = 0;\n    let count = 0;\n    const stuckNodesLength = this.stuckItems.length;\n    const nodeRect = getRectForNode(node);\n\n    while (count < stuckNodesLength) {\n      const stuckNode = this.stuckItems[count].stickyNode;\n\n      if (stuckNode !== node) {\n        const stuckNodeRect = getRectForNode(stuckNode);\n\n        if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {\n          offset += getRectForNode(stuckNode).height;\n        }\n      } else {\n        break;\n      }\n\n      count++;\n    }\n\n    return offset;\n  }\n\n  isNodeStuck(node) {\n    const nodeFound = this.stuckItems.findIndex(({\n      stickyNode\n    }) => node === stickyNode);\n    return nodeFound >= 0;\n  }\n\n  setTopBarOffset(container) {\n    const topbarElement = container.querySelector(`:not(${scrollable.selector}) ${dataPolarisTopBar.selector}`);\n    this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;\n  }\n\n}\n\nfunction isDocument(node) {\n  return node === document;\n}\n\nfunction scrollTopFor(container) {\n  return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;\n}\n\nfunction horizontallyOverlaps(rect1, rect2) {\n  const rect1Left = rect1.left;\n  const rect1Right = rect1.left + rect1.width;\n  const rect2Left = rect2.left;\n  const rect2Right = rect2.left + rect2.width;\n  return rect2Right < rect1Left || rect1Right < rect2Left;\n}\n\nexport { StickyManager };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}